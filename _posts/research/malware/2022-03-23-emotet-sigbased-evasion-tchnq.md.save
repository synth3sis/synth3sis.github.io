---
layout: post
author: synth3sis
title: 'Emotet: signature based evasion & malleable executable'
date: 2022-04-01 12:29 +0100
categories: [Researches, Malware]
tags: [python,hacking,dropper,dll,malleable,infection,executable,evasion,emotet,malware,analysis,xxd,hex,c++]
image: "post-emotet.png"
toc: true
pin: false
---

Recently I came across an interesting finding concerning Emotet's infection kill-chain, that starts with the usual phishing email,
followed by the download of an excel macro, then its execution, which acts as the DLL dropper and finally leads to malware infection.

## Signature

I had a look inside the malicious excel document. The dropper had an embedded list of domains to grab the malware from, in order increase the download
probabilities if one or more of them were eventually unreachable.
Once downloaded the sample I started to look for as many IOCs as possible, so I noticed it had a unique signature.
I fed it to Virus Total, which took its time to digest the sample (it was new!) and then gave me a malicious score of 46 out of 67, so no worries.

![S0367-emt-vt](/assets/img/202204/S0367-emt-vt.png){: .center }

The interesting part was actually the methodology implemented by threat actors to evade the signature based detection.
I double checked every one of them to catch as many indicators as possible, and I noticed that every time I downloaDLL downloaded had a different signature.

```bash
(synth3sis㉿sthsvm)-[~/Emotet]$ sha256sum *.dll
d676b92e998dd3c2dfb6e51f8218019347c8b77d621fbf105fae3f7d7e2cb829  C5VDn1.dll
7a11140df855a04f149152da55819c4a18ded6eff3eaf09cb80332cf24343b42  wSPSASYGrd7.dll
d91fa3bfa7ea9265375b4f89100c54900f083daa115f025203121091a950afc6  XhmFXgaDuArOj.dll
```

So I downloaded three samples of the same malware, all of which have the same size (#IOCs).

```bash
(synth3sis㉿sthsvm)-[~/Emotet]$ du -sb *.dll
626688  C5VDn1.dll
626688  wSPSASYGrd7.dll
626688  XhmFXgaDuArOj.dll

```

Then, I anlyzed the differences between their HEX dump, and this is what I found:

```bash
(synth3sis㉿sthsvm)-[~/Emotet]$ diff C5VDn1.dll.xxd wSPSASYGrd7.dll.xxd
20799,20801c20799,20801
< 00052430  00 00 00 00 00 00 00 00  31 00 00 00 ee b1 51 09  |........1.....Q.|
< 00052440  04 2b d8 a4 bf cf a8 b7  b0 45 5d 86 a3 60 4a 6b  |.+.......E]..`Jk|
< 00052450  63 54 45 82 cf 33 3e eb  0b ab 0f b8 00 00 00 00  |cTE..3>.........|
---
> 00052430  00 00 00 00 00 00 00 00  31 00 00 00 4e f6 a8 65  |........1...N..e|
> 00052440  69 93 98 3f a7 fc 31 0b  1f c6 7e 58 96 45 78 6c  |i..?..1...~X.Exl|
> 00052450  b7 5a 62 8b da 4b a2 a5  df 56 f0 22 00 00 00 00  |.Zb..K...V."....|
```
```bash
# XhmFXgaDuArOj.dll:
> 00052430  00 00 00 00 00 00 00 00  31 00 00 00 48 bb 9a 0f  |........1...H...|
> 00052440  54 44 07 cb f5 4f c6 b1  e6 e8 3c 22 22 37 cd fb  |TD...O....<""7..|
> 00052450  99 8e 6a d4 3a 20 f6 24  c8 bd 12 c8 00 00 00 00  |..j.: .$........|
```

It appears that at offset `5243C` they show variations, more precisely exactly 32 bytes vary (until `5245B` included),
which at first glance seems randomly generated and lacking valuable information embedded into it.

Analyzing the PE's entropy, as expected, `.text` and `.rdata` sections are packed:

![S0367-emt-entropy](/assets/img/202204/S0367-emt-entropy.png){: .center }


## Executable' sequence

I wondered of what is the technical mechanism behind this interesting behaviour and how could be implemented,
so I started doing some research and I came across the concept of 
[**Cobalt Strike Malleable PEs**](https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/malleable-c2-extend_main.htm#_Toc65482852) 
which gave me some insight on C2 agent and malleable PE configurations.

Anyway, my goal was to write a piece of code to give me proof on how could I modify in response to a web request some section of the package and eventually embed
configurations in it.
The cool thing about this stuff was that potentially this PE, once deployed could have been sent all over the network without being detected by signature based detection systems,
such as basic AVs or NIDS of some sort.

At this point I did further research and study just to be able to reproduce this mechanism by writing the right program and create my basic proof of concept.

So I wrote a C++ sample which implements a static preallocated-space buffer used to keep track of the sequence to be later editable. I used the same `C5VDn1.dll` byte array
so I allocated exactly 32 bytes for it. Here is the code of `seqdumper.cpp`:
```cpp
#include <iostream>
#include <fstream>

static unsigned char sequence_buf[32]  = {
        0xEE, 0xB1, 0x51, 0x09, 0x04, 0x2B, 0xD8, 0xA4, 0xBF, 0xCF, 0xA8, 0xB7, 0xB0, 0x45, 0x5D, 0x86,
        0xA3, 0x60, 0x4A, 0x6B, 0x63, 0x54, 0x45, 0x82, 0xCF, 0x33, 0x3E, 0xEB, 0x0B, 0xAB, 0x0F, 0xB8
};

int main() {
        std::ofstream outfile;
        outfile.open("sequence.bin", std::ios_base::binary);
        std::cout << "+ writing down " << sizeof(sequence_buf) << " bytes sequence_buf\n";
        for (int i = 0; i < sizeof(sequence_buf); i++) {
                outfile.write((char*)(sequence_buf + i * sizeof(sequence_buf[0])), sizeof(sequence_buf[0]));
        }
        std::cout << "+ \"sequence.bin\" dumped\n";
        outfile.close();
        return 0;
}
```

And compiled/ran it.

```bash
(synth3sis㉿sthsvm)-[~/Emotet]$ g++ seqdumper.cpp -o agent && ./agent
+ writing down 32 bytes sequence
+ "sequence.bin" dumped

(synth3sis㉿sthsvm)-[~/Emotet]$ xxd sequence.bin
00000000: eeb1 5109 042b d8a4 bfcf a8b7 b045 5d86  ..Q..+.......E].
00000010: a360 4a6b 6354 4582 cf33 3eeb 0bab 0fb8  .`JkcTE..3>.....
```

And I can find the same sequence embedded in `agent`, more precisely in this case, at offset `30a0`.


```bash
(synth3sis㉿sthsvm)-[~/Emotet]$ xxd agent |grep -A1 "eeb1"
000030a0: eeb1 5109 042b d8a4 bfcf a8b7 b045 5d86  ..Q..+.......E].
000030b0: a360 4a6b 6354 4582 cf33 3eeb 0bab 0fb8  .`JkcTE..3>.....
```

## Malleable executable

Now that I have the address, I developed a python script to overwrite exactly that sequence.

```python
#!/usr/bin/env python3

import sys
from os.path import exists

def main():
        if len(sys.argv) <= 1:
                sys.exit("Usage: python3 patchbin.py /path/to/binfile")
        if not exists(sys.argv[1]):
                sys.exit("File does not exists")

        execfile = sys.argv[1]
        patch = b"'7h475_7h3_N3w_''53qu3nc_1nj3c7'"

        with open(execfile, 'rb') as ef:
                data = bytearray(ef.read())
        ef.close()

        # Look for the sequence's first 4 bytes
        offset = data.find(b"\xee\xb1\x51\x09")
        print("-> Patching file at offset " + str(offset))

        with open(execfile, 'r+b') as ef:
                ef.seek(offset)
                ef.write(patch)
        ef.close()
        print("-> " + execfile + " patched")

if __name__ == "__main__":
        main()
```
Finally, I executed `agent` which dropped its sequence to `sequence.bin` binary file.
```bash
(synth3sis㉿sthsvm)-[~/Emotet]$ ./agent
+ writing down 32 bytes sequence
+ "sequence.bin" dumped

(synth3sis㉿sthsvm)-[~/Emotet]$ cat sequence.bin |xxd
00000000: eeb1 5109 042b d8a4 bfcf a8b7 b045 5d86  ..Q..+.......E].
00000010: a360 4a6b 6354 4582 cf33 3eeb 0bab 0fb8  .`JkcTE..3>.....

(synth3sis㉿sthsvm)-[~/Emotet]$ sha256 agent
fd19322c68ba5bbf6ddae23b7a60ad760620d9aafef1f678ca49a7b945e95faf  agent
```
And then patched the executable.
```bash
(synth3sis㉿sthsvm)-[~/Emotet]$ ./patchbin.py agent
-> Patching file at offset 12448
-> agent patched

(synth3sis㉿sthsvm)-[~/Emotet]$ sha256sum agent
82e359b8cf4108b9dfc4367ba46a09be98874b1260406035aa4a84ae0d0d16b4  agent
```
And of course the executable's signature has changed. But let's see if when executed, it dumps the patched byte array we set.

```bash
(synth3sis㉿sthsvm)-[~/Emotet]$ ./agent
+ writing down 32 bytes sequence
+ "sequence.bin" dumped

(synth3sis㉿sthsvm)-[~/Emotet]$ cat sequence.bin |xxd
00000000: 2737 6834 3735 5f37 6833 5f4e 3377 5f27  '7h475_7h3_N3w_'
00000010: 2735 3371 7533 6e63 5f31 6e6a 3363 3727  '53qu3nc_1nj3c7'
```

<br>

---

<br>

If any other idea about this case of study comes to mind, I will update it so stay tuned and feel free to contact me if you
think I did something wrong or I just could have done something better.

Coming Soon!

In the next write-up I will deepen the subject further to see if I can manage to embed structured informations
useful for configuration with a PoC of client-server communication.

